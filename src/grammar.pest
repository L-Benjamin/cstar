// Quiet rules

WHITESPACE = _{ " " | "\t" | "\n" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }


// Common definitions

ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
void = { "void" }
bool = { true_ | false_ } true_ = { "true" } false_ = { "false" }
int = @{ (ASCII_DIGIT+ | "0x" ~ ASCII_HEX_DIGIT+ | "0b" ~ ASCII_BIN_DIGIT+) }
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ ("e" ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
char = @{ "'" ~ "\\"? ~ ANY ~ "'" }
string = @{ "\"" ~ (("\\" | !"\"") ~ ANY)* ~ "\"" }


// Files

program = { SOI ~ element* ~ init ~ run ~ EOI }
init = { "Init" ~ "[" ~ (ident ~ ",")* ~ ident? ~ "]" ~ ";" }
run = { "Run" ~ "[" ~ (ident ~ ",")* ~ ident? ~ "]" ~ ";" }


// Elements

element = { component | resource | system | const_decl ~ ";" }
component = { "Component" ~ ident ~ struct_ }
resource = { "Resource" ~ ident ~ struct_ }
system = { "System" ~ ident ~ filter_list ~ block }


// Curly braces and blocks

struct_ = { "{" ~ (type_ ~ ident ~ ";")* ~ "}" }
block = { "{" ~ stmt* ~ "}" }


// Assignements and declarations

assign = { lvalue ~ "=" ~ expr }
decl = { type_ ~ (assign | ident) }
const_decl = { "const" ~ type_ ~ assign }


// Types

primitive = { "void" | "bool" | "int" | "float" | "char" | "string" | "System" | "Entity" }
type_ = { primitive | ident }


// Filters and queries

const_ = { "const" }
typed_ident = { const_? ~ type_ ~ ident }
entity_filter = { "Entity" ~ ident ~ ("," ~ typed_ident)* ~ ","? }
resource_filter = { typed_ident }
filter = _{ entity_filter | resource_filter }
filter_list = { "(" ~ (filter ~ ";")* ~ filter? ~ ")" }


// Builtins and calls

builtin = { clone | delete | spawn | print }
clone = { "Clone" } delete = { "Delete" }
spawn = { "Spawn" } print = { "Print" }
call = { builtin ~ "(" ~ (expr ~ ",")* ~ expr? ~ ")" }


// L-values

access = { ident ~ ("." ~ ident)+ }
lvalue = { access | ident }


// Values

atom = _{ void | bool | int | float | char | string }
cast = { "(" ~ type_ ~ ")" ~ value }
struct_init = { ident ~ "{" ~ (ident ~ ":" ~ expr ~ ";")* ~ "}" }
value = { atom | call | cast | struct_init | assign | lvalue }


// Binary operators and expressions

binop = _{ add | sub | mul | div | mod_ | and | or | xor | bitand | bitor | shl | shr | leq | geq | lt | gt | eq | neq }
add = { "+" }  sub = { "-" }  mul = { "*" }  div = { "/" }    mod_ = { "%" }
and = { "&&" } or = { "||" }  xor = { "^" }  bitand = { "&" } bitor = { "|" }
shl = { "<<" } shr = { ">>" } leq = { "<=" } geq = { ">=" }   lt = { "<" }  
gt = { ">" }   eq = { "==" }  neq = { "!=" }
binexpr = { term ~ (binop ~ term)+ }


// Unary operators and expressions

unop = _{ pos | neg | not | bitnot }
pos = { "+" } neg = { "-" } not = { "!" } bitnot = { "~" }
unexpr = { unop ~ term }


// Terms and expressions

term = _{ value | unexpr | "(" ~ expr ~ ")" }
expr = { binexpr | term }


// Statements

if_ = { "if" ~ "(" ~ expr ~ ")" ~ block ~ ("else" ~ block)? }
for_ = { "for" ~ "(" ~ (expr | decl)? ~ ";" ~ expr? ~ ";" ~ expr? ~ ")" ~ block }
while_ = { "while" ~ "(" ~ expr ~ ")" ~ block }
query = { "query" ~ filter_list ~ block }
break_ = { "break" }
continue_ = { "continue" }
stmt = { if_ | for_ | while_ | query | block | (expr | decl | const_decl | break_ | continue_) ~ ";" }